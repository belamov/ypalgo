package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
)

//https://contest.yandex.ru/contest/25070/problems/B/

// https://contest.yandex.ru/contest/25070/run-report/87391156/ - ссылка на последнее ОК решение

// В стране X есть n городов, которым присвоены номера от 1 до n.
//Столица страны имеет номер n.
//Между городами проложены железные дороги.
//
//Однако дороги могут быть двух типов по ширине полотна.
//Любой поезд может ездить только по одному типу полотна.
//Условно один тип дорог помечают как R, а другой как B.
//То есть если маршрут от одного города до другого имеет как дороги типа R, так и дороги типа B, то ни один
//поезд не сможет по этому маршруту проехать.
//От одного города до другого можно проехать только по маршруту, состоящему
//исключительно из дорог типа R или только из дорог типа B.
//
//Но это ещё не всё.
//По дорогам страны X можно двигаться только от города с меньшим номером к городу с большим номером.
//Это объясняет большой приток жителей в столицу, у которой номер n.
//
//Карта железных дорог называется оптимальной, если не существует
//пары городов A и B такой, что от A до B можно добраться как по дорогам
//типа R, так и по дорогам типа B.
//Иными словами, для любой пары городов верно, что от города с меньшим
//номером до города с бОльшим номером можно добраться по дорогам
//только какого-то одного типа или же что маршрут
//построить вообще нельзя.
//Выясните, является ли данная вам карта оптимальной.
//

//Представим карту железных дорог графом, где номера городов будут вершинами, а железные дороги - ребрами.
//Мы можем двигаться только из города с меньшим номером в город с большим номером.
//Если мы будем считать, что дороги с типом B ведут от большего номера к меньшему (как по условию задачи), а
//дороги с типом R ведут обратно, то задача сводится к поиске цикла в графе. Если цикл присутствует, то это
//значит, что между городами можно добраться разными типами дорог.
//Другими словами, если в графе железных дорог, в котором разные типы дорог ведут в разные направления, есть цикл, то
//карта не является оптимальной.
//
//Поиск цикла будем осуществлять при помощи поиска в глубину. Если при проверке смежных по исходящим
//дугам вершин очередная вершина окажется серой — цикл есть.

// -- ВРЕМЕННАЯ СЛОЖНОСТЬ --
// O(N^2), где N - количество городов
//Мы тратим время на обход графа в глубину. Обход графа занимает
// O(V+E), где V - количество вершин (городов), E - количество ребер
//У нас количество вершин = количество городов, то есть V = N
//Количество ребер = количество дорог между городами.
//По условию задачи из первого города есть дорога во все остальные, из второго - во все, кроме первого,
//из третьего - во все кроме первого и второго
//Это арифметическая прогрессия с разницей -1
//Сумма этой арифметической прогрессии - общее количество дорог.
//Получается, что дорог между городами (ребер в графе) S = (a1+aN)/2*N = (N-1+0)/2*N = (N^2-N)/2
//Подставим получившиеся значения в оценку сложности обхода графа в глубину, получим
//O(V+E) = O(N+(N^2-N)/2) = O((N^2-N+2N)/2) ~ O(N^2)

// -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
//O(N^2)
// Для хранения списка смежности графа нам понадобится O(V+E), где V - количество вершин, E - количество ребер
//Это эквивалентно оценке временной сложности (см. выше)
func main() {
	scanner := makeScanner()
	n := readInt(scanner)

	adjList := make([][]int, n)

	for i := 0; i < n-1; i++ {
		ways := readString(scanner)

		for j, direction := range ways {
			var vertexFrom, vertexTo int
			vertexFrom = i
			vertexTo = i + j + 1
			//Если это дорога с типом "R", то в графе она будет в обратном направлении
			if direction == 82 { // "R"
				vertexFrom, vertexTo = vertexTo, vertexFrom
			}

			if adjList[vertexFrom] == nil {
				adjList[vertexFrom] = make([]int, 0)
			}
			adjList[vertexFrom] = append(adjList[vertexFrom], vertexTo)
		}
	}

	if graphHasCycles(adjList) {
		fmt.Print("NO")
	} else {
		fmt.Print("YES")
	}

}

func graphHasCycles(adjList [][]int) bool {
	color := make([]int, len(adjList))
	var stack []int

	for i := 0; i < len(color); i++ {
		if color[i] != 0 {
			continue
		}

		stack = []int{i}

		for len(stack) > 0 {
			v := stack[len(stack)-1]     // Получаем из стека очередную вершину.
			stack = stack[:len(stack)-1] // Удаляем вершину из стека.

			if color[v] == 0 {
				// Красим вершину в серый. И сразу кладём её обратно в стек:
				// это позволит алгоритму позднее вспомнить обратный путь по графу.
				color[v] = 1

				stack = append(stack, v)
				// Теперь добавляем в стек все непосещённые соседние вершины,
				// вместо вызова рекурсии
				for _, w := range adjList[v] { // Перебираем смежные вершины.
					if color[w] == 0 { // Если вершина не посещена, то
						stack = append(stack, w)
					}
					//Если при проверке смежных по исходящим
					//дугам вершин очередная вершина окажется серой — цикл есть
					if color[w] == 1 {
						return true
					}
				}
				continue
			}

			if color[v] == 1 {
				// Серую вершину мы могли получить из стека только на обратном пути.
				// Следовательно, её следует перекрасить в чёрный.
				color[v] = 2
			}
		}
	}

	// мы прошли граф в глубину и не нашли циклов
	return false
}

func makeScanner() *bufio.Scanner {
	const maxCapacity = 7 * 1024 * 1024
	buf := make([]byte, maxCapacity)
	scanner := bufio.NewScanner(os.Stdin)
	scanner.Buffer(buf, maxCapacity)
	return scanner
}

func readString(scanner *bufio.Scanner) string {
	scanner.Scan()
	return scanner.Text()
}

func readInt(scanner *bufio.Scanner) int {
	scanner.Scan()
	stringInt := scanner.Text()
	res, _ := strconv.Atoi(stringInt)
	return res
}
