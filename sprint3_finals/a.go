package main

// https://contest.yandex.ru/contest/23815/problems/A/

//Алла ошиблась при копировании из одной структуры данных в другую.
//Она хранила массив чисел в кольцевом буфере.
//Массив был отсортирован по возрастанию, и в нём можно было найти элемент за логарифмическое время.
//Алла скопировала данные из кольцевого буфера в обычный массив, но сдвинула данные
//исходной отсортированной последовательности.
//Теперь массив не является отсортированным.
//Тем не менее, нужно обеспечить возможность находить в нем элемент за O(log n).
//Можно предполагать, что в массиве только уникальные элементы.
//
// https://contest.yandex.ru/contest/23815/run-report/81834163/ - ссылка на последнее ОК решение

// Задача решается небольшой доработкой алгоритма бинарного поиска.
// Вместо простого выбора, какую половину массива выбрать для дальнейшего поиска (если элемент больше, то
// выбираем правую половину, а если меньше - то левую), мы будем выбирать половину следующим образом:
// - если искомый элемент находится в границах левой половины (искомый элемент больше первого элемента
//   половины и меньше последнего элемента половины), то выбираем левую половину
// - если в левой половине есть сдвиг (первый элемент половины больше последнего) и оба конца половины
//   не меньше искомого, то выбираем левую половину
// - в остальных случаях выбираем правую половину
//
// -- ВРЕМЕННАЯ СЛОЖНОСТЬ --
// алгоритм работает за O(log(n)), где n - длина массива, поскольку это алгоритм бинарного
// поиска с измененным условием выбора половины
// на каждом шаге мы уменьшаем искомую область примерно вдвое, что дает логарифмическую оценку
//
// -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
// мы не создаем новых структур данных, поэтому алгоритм потребляет O(1) памяти и не зависит от длины массива
func brokenSearch(arr []int, k int) int {
	return binarySearch(arr, k, 0, len(arr)-1)
}

func binarySearch(arr []int, x int, left int, right int) int {
	if left == right {
		if arr[left] == x {
			return left
		}
		return -1
	}

	mid := (left + right) / 2

	if arr[mid] == x {
		return mid
	}

	if arr[left] <= x && arr[mid] >= x {
		return binarySearch(arr, x, left, mid)
	}

	if arr[left] >= x && arr[mid] >= x && arr[left] > arr[mid] {
		return binarySearch(arr, x, left, mid)
	}

	return binarySearch(arr, x, mid+1, right)
}
