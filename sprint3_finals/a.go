package main

// https://contest.yandex.ru/contest/23815/problems/A/

//Алла ошиблась при копировании из одной структуры данных в другую.
//Она хранила массив чисел в кольцевом буфере.
//Массив был отсортирован по возрастанию, и в нём можно было найти элемент за логарифмическое время.
//Алла скопировала данные из кольцевого буфера в обычный массив, но сдвинула данные
//исходной отсортированной последовательности.
//Теперь массив не является отсортированным.
//Тем не менее, нужно обеспечить возможность находить в нем элемент за O(log n).
//Можно предполагать, что в массиве только уникальные элементы.
//
// https://contest.yandex.ru/contest/23815/run-report/82008293/ - ссылка на последнее ОК решение

// Задача решается небольшой доработкой алгоритма бинарного поиска.
// Вместо простого выбора, какую половину массива выбрать для дальнейшего поиска (если элемент больше, то
// выбираем правую половину, а если меньше - то левую), мы будем выбирать половину следующим образом:
// - если искомый элемент находится в границах левой половины (искомый элемент больше первого элемента
//   половины и меньше последнего элемента половины), то выбираем левую половину
// - если в левой половине есть сдвиг (первый элемент половины больше последнего) и искомый элемент больше
//   начала левой половины или меньше конца правой половины
// - в остальных случаях выбираем правую половину
//
// -- ВРЕМЕННАЯ СЛОЖНОСТЬ --
// алгоритм работает за O(log(n)), где n - длина массива, поскольку это алгоритм бинарного
// поиска с измененным условием выбора половины
// на каждом шаге мы уменьшаем искомую область примерно вдвое, что дает логарифмическую оценку
//
// -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
// мы не создаем новых структур данных и не делаем рекурсивных вызовов, поэтому алгоритм
// потребляет O(1) памяти и не зависит от длины массива
func brokenSearch(arr []int, k int) int {
	return binarySearch(arr, k, 0, len(arr)-1)
}

func binarySearch(arr []int, x int, left int, right int) int {
	for left != right {
		mid := (left + right) / 2

		if arr[mid] == x {
			return mid
		}

		// если искомый элемент между концами левой половины
		if arr[left] <= x && arr[mid] >= x {
			// то ищем дальше в левой половине
			right = mid
			continue
		}

		// если сдвиг в левой половине и искомый элемент больше начала половины или меньше конца половины
		if arr[left] > arr[mid] && (arr[left] <= x || arr[mid] >= x) {
			// то ищем дальше в левой половине
			right = mid
			continue
		}

		// в остальных случаях ищем в правой половине
		left = mid + 1
	}

	if arr[left] == x {
		return left
	}

	return -1
}

func main() {
	brokenSearch([]int{}, 1)
}
