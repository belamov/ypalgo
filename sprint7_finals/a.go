package main

import (
	"bufio"
	"fmt"
	"os"
)

//https://contest.yandex.ru/contest/25597/problems/A/

// https://contest.yandex.ru/contest/25597/run-report/87786784/ - ссылка на последнее ОК решение

//Расстоянием Левенштейна между двумя строками s и t называется количество атомарных
//изменений, с помощью которых можно одну строку превратить в другую.
//Под атомарными изменениями подразумеваются:
//удаление одного символа, вставка одного символа, замена одного символа на другой.
//Найдите расстояние Левенштейна для предложенной пары строк.
//Выведите единственное число — расстояние между строками.

//Данную задачу можно решить при помощи двумерного динамического программирования:

// - Что будет храниться в dp?
//   dp[i][j] -минимальное количество операций для преобразования строки из i первых символов s
//              в строку из j первых символов t
//
// - Каким будет базовый случай для задачи?
//   Очевидно, что редакционное расстояние между двумя пустыми строками равно нулю.
//   Так же очевидно то, что чтобы получить пустую строку из строки длиной i, нужно совершить i операций удаления,
//   а чтобы получить строку длиной j из пустой, нужно произвести j операций вставки.
//
// - Каким будет переход динамики?
//   Пусть Si (первые i символов s) кончается на символ «a», Tj (первые j символов t) кончается на символ «b». Есть три варианта:
//   (1) Символ «а», на который кончается Si, в какой-то момент был стёрт.
//       Сделаем это стирание первой операцией.
//       Тогда мы стёрли символ «a», после чего превратили первые i-1 символов Si в Sj (на что потребовалось dp[i-1][j] операций),
//       значит, всего потребовалось dp[i-1][j]+1 операций
//   (2) Символ «b», на который кончается Sj, в какой-то момент был добавлен.
//       Сделаем это добавление последней операцией.
//       Мы превратили Si в первые j-1 символов Sj, после чего добавили «b».
//       Аналогично предыдущему случаю, потребовалось dp[i][j-1]+1 операций.
//   (3) Оба предыдущих утверждения неверны.
//       Если мы добавляли символы справа от финального «a», то, чтобы сделать последним символом «b», мы должны
//       были или в какой-то момент добавить его (но тогда утверждение 2 было бы верно), либо заменить на него
//       один из этих добавленных символов (что тоже невозможно, потому что добавление
//       символа с его последующей заменой неоптимально).
//       Значит, символов справа от финального «a» мы не добавляли.
//       Самого финального «a» мы не стирали, поскольку утверждение 1 неверно.
//       Значит, единственный способ изменения последнего символа — его замена.
//       Заменять его 2 или больше раз неоптимально.
//       Значит,
//          - Если a=b, мы последний символ не меняли.
//            Поскольку мы его также не стирали и не приписывали ничего справа от него, он не влиял
//            на наши действия, и, значит, мы выполнили dp[i-1][j-1] операций.
//          - Если a!=b, мы последний символ меняли один раз.
//            Сделаем эту замену первой.
//            В дальнейшем, аналогично предыдущему случаю, мы должны выполнить dp[i-1][j-1] операций, значит, всего
//            потребуется dp[i-1][j-1]+1 операций.
//   Нам остается только выбрать минимальное значение из этих трех вариантов
//   также заметим, что для расчета текущей строки нам нужна только предыдущая строка, а значит мы можем
//   не хранить весь массив dp, а обойтись только текущей и предыдущей строкой
//
// - Каким будет порядок вычисления данных в массиве dp?
//   от dp[0][0] до dp[i][j]
//
// - Где будет располагаться ответ на исходный вопрос?
//   в dp[i][j]

// -- ВРЕМЕННАЯ СЛОЖНОСТЬ --
// O(N*M), где N - количество символов в s, M - количество символов в t

// -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
// O(S), где S - минимальное значение из длин s и t
func main() {
	scanner := makeScanner()
	s := readString(scanner)
	t := readString(scanner)

	fmt.Println(minDistance(s, t))
}

func minDistance(s, t string) int {
	//в s будет кратчайшая из двух строка,
	//чтобы слегка оптимизировать по памяти
	if len(t) < len(s) {
		s, t = t, s
	}

	prev := make([]int, len(s)+1)
	curr := make([]int, len(s)+1)

	for i := 0; i <= len(t); i++ {
		for j := 0; j <= len(s); j++ {
			if i == 0 && j == 0 {
				curr[j] = 0
				continue
			}

			if i == 0 {
				curr[j] = j
				continue
			}

			if j == 0 {
				curr[j] = i
				continue
			}

			ops := 0
			if s[j-1] != t[i-1] {
				ops = 1
			}
			curr[j] = min(prev[j]+1, curr[j-1]+1, prev[j-1]+ops)
		}
		curr, prev = prev, curr
	}
	return prev[len(s)]
}

func min(a, b, c int) int {
	m := a
	if b < m {
		m = b
	}
	if c < m {
		m = c
	}
	return m
}

func makeScanner() *bufio.Scanner {
	const maxCapacity = 20 * 1024 * 1024
	buf := make([]byte, maxCapacity)
	scanner := bufio.NewScanner(os.Stdin)
	scanner.Buffer(buf, maxCapacity)
	return scanner
}

func readString(scanner *bufio.Scanner) string {
	scanner.Scan()
	return scanner.Text()
}
