package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
	"strings"
)

// https://contest.yandex.ru/contest/22781/run-report/80434059/ - ссылка на последнее ОК решение

// https://contest.yandex.ru/contest/22781/problems/B/

// Задание связано с обратной польской нотацией.
//Она используется для парсинга арифметических выражений.
//Еще её иногда называют постфиксной нотацией.
//
//В постфиксной нотации операнды расположены перед знаками операций.
//
//Пример 1:
//3 4 +
//означает 3 + 4 и равно 7
//
//Пример 2:
//12 5 /
//Так как деление целочисленное, то в результате получим 2.
//
//Пример 3:
//10 2 4 * -
//означает 10 - 2 * 4 и равно 2
//
//Разберём последний пример подробнее:
//
//Знак * стоит сразу после чисел 2 и 4, значит к ним нужно применить операцию, которую
//этот знак обозначает, то есть перемножить эти два числа. В результате получим 8.
//
//После этого выражение приобретёт вид:
//
//10 8 -
//
//Операцию «минус» нужно применить к двум идущим перед ней числам, то есть 10 и 8. В итоге получаем 2.
//
//Рассмотрим алгоритм более подробно. Для его реализации будем использовать стек.
//
//Для вычисления значения выражения, записанного в обратной
//польской нотации, нужно считывать выражение слева направо и придерживаться следующих шагов:
//
//Обработка входного символа:
//- Если на вход подан операнд, он помещается на вершину стека.
//- Если на вход подан знак операции, то эта операция выполняется над
//требуемым количеством значений, взятых из стека в порядке добавления.
//Результат выполненной операции помещается на вершину стека.
//- Если входной набор символов обработан не полностью, перейти к шагу 1.
//После полной обработки входного набора символов результат вычисления выражения находится в вершине стека.
//Если в стеке осталось несколько чисел, то надо вывести только верхний элемент.
//
//Замечание про отрицательные числа и деление:
//в этой задаче под делением понимается математическое целочисленное деление.
//Это значит, что округление всегда происходит вниз.
//А именно: если a / b = c, то b ⋅ c — это наибольшее число, которое
//не превосходит a и одновременно делится без остатка на b.
//
//Например, -1 / 3 = -1. Будьте осторожны: в C++, Java и Go, например, деление чисел работает иначе.
//
//В текущей задаче гарантируется, что деления на отрицательное число нет.
//
// -- ВРЕМЕННАЯ СЛОЖНОСТЬ --
// каждый символ в строке либо помещается на стек, либо выполняется операция с двумя предыдущими
// числами. поэтому вся последовательность обрабатывается за О(n), где n - количество операций/операндов
//
// -- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
// в стек будет добавлен каждый операнд
// исходя из формата польской нотации n/2+1 будет операндами, а значит хранить мы будем n/2+1 операндов.
// оценка O(n/2+1) = O(n/2)+o(1) ~ O(n/2) ~ O(n), где n - количество символов, разделенных пробелами
//
func calculate(input string) int {
	commands := strings.Split(input, " ")
	var stack *ListNode
	for _, char := range commands {
		number, err := strconv.Atoi(char)

		if err == nil {
			// если на вход подан операнд, он помещается на вершину стека.
			stack = &ListNode{
				number: number,
				prev:   stack,
			}
			continue
		}

		// если на вход подан знак операции, то эта операция выполняется
		// над требуемым количеством значений, взятых из стека
		// в порядке добавления.
		secondOperand := stack.number
		stack = stack.prev
		firstOperand := stack.number
		stack = stack.prev
		var result int

		switch char {
		case "+":
			result = firstOperand + secondOperand
		case "-":
			result = firstOperand - secondOperand
		case "*":
			result = firstOperand * secondOperand
		case "/":
			//в этой задаче под делением понимается математическое целочисленное деление.
			//Это значит, что округление всегда происходит вниз.
			//А именно: если a / b = c, то b ⋅ c — это наибольшее число, которое
			//не превосходит a и одновременно делится без остатка на b.
			result = firstOperand / secondOperand
			if secondOperand*result > firstOperand {
				result--
			}
		}

		// результат выполненной операции помещается на вершину стека
		stack = &ListNode{
			number: result,
			prev:   stack,
		}
	}

	// после полной обработки входного набора символов результат вычисления выражения находится в вершине стека.
	// если в стеке осталось несколько чисел, то надо вывести только верхний элемент
	return stack.number
}

type ListNode struct {
	number int
	prev   *ListNode
}

func main() {
	scanner := makeScanner()
	commands := readLine(scanner)
	fmt.Println(calculate(commands))
}

func makeScanner() *bufio.Scanner {
	const maxCapacity = 3 * 1024 * 1024
	buf := make([]byte, maxCapacity)
	scanner := bufio.NewScanner(os.Stdin)
	scanner.Buffer(buf, maxCapacity)
	return scanner
}

func readLine(scanner *bufio.Scanner) string {
	scanner.Scan()
	return scanner.Text()
}
